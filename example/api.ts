// tslint:disable
/**
 * Swagger Petstore
 * This is a sample server Petstore server.  You can find out more about Swagger at [http://swagger.io](http://swagger.io) or on [irc.freenode.net, #swagger](http://swagger.io/irc/).  For this sample, you can use the api key `special-key` to test the authorization filters.
 *
 * OpenAPI spec version: 1.0.0
 * Contact: apiteam@swagger.io
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


export const BASE_PATH = "http://petstore.swagger.io/v2".replace(/\/+$/, "");


export interface ApiResponse {
    code?: number; 
    type?: string; 
    message?: string; 
}


export interface Category {
    id?: number; 
    name?: string; 
}


export interface Order {
    id?: number; 
    petId?: number; 
    quantity?: number; 
    shipDate?: Date; 
    status?: Order.StatusEnum; // Order Status
    complete?: boolean; 
}

export namespace Order {
    export enum StatusEnum {
        Placed = <any> 'placed', // Order Status
        Approved = <any> 'approved', // Order Status
        Delivered = <any> 'delivered' // Order Status
    }
}


export interface Pet {
    id?: number; 
    category?: Category; 
    name: string; 
    photoUrls: Array<string>; 
    tags?: Array<Tag>; 
    status?: Pet.StatusEnum; // pet status in the store
}

export namespace Pet {
    export enum StatusEnum {
        Available = <any> 'available', // pet status in the store
        Pending = <any> 'pending', // pet status in the store
        Sold = <any> 'sold' // pet status in the store
    }
}


export interface Tag {
    id?: number; 
    name?: string; 
}


export interface User {
    id?: number; 
    username?: string; 
    firstName?: string; 
    lastName?: string; 
    email?: string; 
    password?: string; 
    phone?: string; 
    userStatus?: number; // User Status
}


export interface AddPetRequest {
    body: Pet;
}

export interface DeletePetRequest {
    petId: number;
    apiKey?: string;
}

export interface FindPetsByStatusRequest {
    status: Array<string>;
}

export interface FindPetsByTagsRequest {
    tags: Array<string>;
}

export interface GetPetByIdRequest {
    petId: number;
}

export interface UpdatePetRequest {
    body: Pet;
}

export interface UpdatePetWithFormRequest {
    petId: number;
    name?: string;
    status?: string;
}

export interface UploadFileRequest {
    petId: number;
    additionalMetadata?: string;
    file?: any;
}

export interface DeleteOrderRequest {
    orderId: number;
}

export interface GetOrderByIdRequest {
    orderId: number;
}

export interface PlaceOrderRequest {
    body: Order;
}

export interface CreateUserRequest {
    body: User;
}

export interface CreateUsersWithArrayInputRequest {
    body: Array<User>;
}

export interface CreateUsersWithListInputRequest {
    body: Array<User>;
}

export interface DeleteUserRequest {
    username: string;
}

export interface GetUserByNameRequest {
    username: string;
}

export interface LoginUserRequest {
    username: string;
    password: string;
}

export interface UpdateUserRequest {
    username: string;
    body: User;
}


/**
 * This is the base class for all generated API classes.
 */
export class BaseAPI {

    private middleware: Middleware[];

    constructor(protected configuration = new Configuration()) {
        this.middleware = configuration.middleware;
    }

    withMiddleware(...middlewares: Middleware[]) {
        middlewares.forEach((middleware) => this.middleware.push(middleware));
        return this;
    }

    withPreMiddleware(...preMiddlewares: Array<Middleware['pre']>) {
        const middlewares = preMiddlewares.map((pre) => ({ pre }));
        return this.withMiddleware(...middlewares);
    }

    withPostMiddleware(...postMiddlewares: Array<Middleware['post']>) {
        const middlewares = postMiddlewares.map((post) => ({ post }));
        return this.withMiddleware(...middlewares);
    }

    protected async request<T>(context: RequestOpts): Promise<T> {
        const { url, init } = this.createFetchParams(context);
        const response = await this.fetchApi(url, init);
        if (response.status >= 200 && response.status < 300) {
            if (context.responseType === 'JSON') {
                const result = await response.json() as T;
                return transformPropertyNames(result, context.modelPropertyNaming);
            }
            return response as any as T;
        }
        throw response;
    }

    private createFetchParams(context: RequestOpts) {
        let url = this.configuration.basePath + context.path;
        if (context.query !== undefined) {
             url += '?' + querystring(context.query);
        }
        const body = context.body instanceof FormData ? context.body : JSON.stringify(context.body);
        const init = {
            method: context.method,
            headers: context.headers,
            body,
        };
        return { url, init };
    }

    private fetchApi = async (url: string, init: RequestInit) => {
        let fetchParams = { url, init };
        for (const middleware of this.middleware) {
            if (middleware.pre) {
                fetchParams = await middleware.pre(this.fetchApi, fetchParams.url, fetchParams.init) || fetchParams;
            }
        }
        let response = await this.configuration.fetchApi(fetchParams.url, fetchParams.init);
        for (const middleware of this.middleware) {
            if (middleware.post) {
                response = await middleware.post(this.fetchApi, url, init, response.clone()) || response;
            }
        }
        return response;
    }
};

export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}


/**
 * no description
 */
export class PetApi extends BaseAPI {

    /**
     * 
     * Add a new pet to the store
     */
    async addPet(requestParameters: AddPetRequest): Promise<Response> {
        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new RequiredError('body','Required parameter requestParameters.body was null or undefined when calling addPet.');
        }

        const headerParameters: HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        return this.request<Response>({
            path: `/pet`,
            method: 'POST',
            headers: headerParameters,
            body: requestParameters.body,
            modelPropertyNaming: 'camelCase',
        });
    }

    /**
     * 
     * Deletes a pet
     */
    async deletePet(requestParameters: DeletePetRequest): Promise<Response> {
        if (requestParameters.petId === null || requestParameters.petId === undefined) {
            throw new RequiredError('petId','Required parameter requestParameters.petId was null or undefined when calling deletePet.');
        }

        const headerParameters: HTTPHeaders = {};

        return this.request<Response>({
            path: `/pet/{petId}`.replace(`{${"petId"}}`, encodeURIComponent(String(requestParameters.petId))),
            method: 'DELETE',
            headers: headerParameters,
            modelPropertyNaming: 'camelCase',
        });
    }

    /**
     * Multiple status values can be provided with comma separated strings
     * Finds Pets by status
     */
    async findPetsByStatus(requestParameters: FindPetsByStatusRequest): Promise<Array<Pet>> {
        if (requestParameters.status === null || requestParameters.status === undefined) {
            throw new RequiredError('status','Required parameter requestParameters.status was null or undefined when calling findPetsByStatus.');
        }

        const queryParameters: HTTPQuery = {};

        if (requestParameters.status) {
            queryParameters['status'] = requestParameters.status;
        }

        const headerParameters: HTTPHeaders = {};

        return this.request<Array<Pet>>({
            path: `/pet/findByStatus`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
            responseType: 'JSON',
            modelPropertyNaming: 'camelCase',
        });
    }

    /**
     * Muliple tags can be provided with comma separated strings. Use tag1, tag2, tag3 for testing.
     * Finds Pets by tags
     */
    async findPetsByTags(requestParameters: FindPetsByTagsRequest): Promise<Array<Pet>> {
        if (requestParameters.tags === null || requestParameters.tags === undefined) {
            throw new RequiredError('tags','Required parameter requestParameters.tags was null or undefined when calling findPetsByTags.');
        }

        const queryParameters: HTTPQuery = {};

        if (requestParameters.tags) {
            queryParameters['tags'] = requestParameters.tags;
        }

        const headerParameters: HTTPHeaders = {};

        return this.request<Array<Pet>>({
            path: `/pet/findByTags`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
            responseType: 'JSON',
            modelPropertyNaming: 'camelCase',
        });
    }

    /**
     * Returns a single pet
     * Find pet by ID
     */
    async getPetById(requestParameters: GetPetByIdRequest): Promise<Pet> {
        if (requestParameters.petId === null || requestParameters.petId === undefined) {
            throw new RequiredError('petId','Required parameter requestParameters.petId was null or undefined when calling getPetById.');
        }

        const headerParameters: HTTPHeaders = {};

        return this.request<Pet>({
            path: `/pet/{petId}`.replace(`{${"petId"}}`, encodeURIComponent(String(requestParameters.petId))),
            method: 'GET',
            headers: headerParameters,
            responseType: 'JSON',
            modelPropertyNaming: 'camelCase',
        });
    }

    /**
     * 
     * Update an existing pet
     */
    async updatePet(requestParameters: UpdatePetRequest): Promise<Response> {
        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new RequiredError('body','Required parameter requestParameters.body was null or undefined when calling updatePet.');
        }

        const headerParameters: HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        return this.request<Response>({
            path: `/pet`,
            method: 'PUT',
            headers: headerParameters,
            body: requestParameters.body,
            modelPropertyNaming: 'camelCase',
        });
    }

    /**
     * 
     * Updates a pet in the store with form data
     */
    async updatePetWithForm(requestParameters: UpdatePetWithFormRequest): Promise<Response> {
        if (requestParameters.petId === null || requestParameters.petId === undefined) {
            throw new RequiredError('petId','Required parameter requestParameters.petId was null or undefined when calling updatePetWithForm.');
        }

        const headerParameters: HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/x-www-form-urlencoded';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("petstore_auth", ["write:pets", "read:pets"]);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const formData = new FormData();
        if (requestParameters.name !== undefined) {
            formData.set('name', requestParameters.name as any);
        }

        if (requestParameters.status !== undefined) {
            formData.set('status', requestParameters.status as any);
        }

        return this.request<Response>({
            path: `/pet/{petId}`.replace(`{${"petId"}}`, encodeURIComponent(String(requestParameters.petId))),
            method: 'POST',
            headers: headerParameters,
            body: formData,
            modelPropertyNaming: 'camelCase',
        });
    }

    /**
     * 
     * uploads an image
     */
    async uploadFile(requestParameters: UploadFileRequest): Promise<ApiResponse> {
        if (requestParameters.petId === null || requestParameters.petId === undefined) {
            throw new RequiredError('petId','Required parameter requestParameters.petId was null or undefined when calling uploadFile.');
        }

        const headerParameters: HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/x-www-form-urlencoded';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("petstore_auth", ["write:pets", "read:pets"]);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const formData = new FormData();
        if (requestParameters.additionalMetadata !== undefined) {
            formData.set('additionalMetadata', requestParameters.additionalMetadata as any);
        }

        if (requestParameters.file !== undefined) {
            formData.set('file', requestParameters.file as any);
        }

        return this.request<ApiResponse>({
            path: `/pet/{petId}/uploadImage`.replace(`{${"petId"}}`, encodeURIComponent(String(requestParameters.petId))),
            method: 'POST',
            headers: headerParameters,
            body: formData,
            responseType: 'JSON',
            modelPropertyNaming: 'camelCase',
        });
    }

}

/**
 * no description
 */
export class StoreApi extends BaseAPI {

    /**
     * For valid response try integer IDs with positive integer value. Negative or non-integer values will generate API errors
     * Delete purchase order by ID
     */
    async deleteOrder(requestParameters: DeleteOrderRequest): Promise<Response> {
        if (requestParameters.orderId === null || requestParameters.orderId === undefined) {
            throw new RequiredError('orderId','Required parameter requestParameters.orderId was null or undefined when calling deleteOrder.');
        }

        const headerParameters: HTTPHeaders = {};

        return this.request<Response>({
            path: `/store/order/{orderId}`.replace(`{${"orderId"}}`, encodeURIComponent(String(requestParameters.orderId))),
            method: 'DELETE',
            headers: headerParameters,
            modelPropertyNaming: 'camelCase',
        });
    }

    /**
     * Returns a map of status codes to quantities
     * Returns pet inventories by status
     */
    async getInventory(): Promise<{ [key: string]: number; }> {
        const headerParameters: HTTPHeaders = {};

        return this.request<{ [key: string]: number; }>({
            path: `/store/inventory`,
            method: 'GET',
            headers: headerParameters,
            responseType: 'JSON',
            modelPropertyNaming: 'camelCase',
        });
    }

    /**
     * For valid response try integer IDs with value >= 1 and <= 10. Other values will generated exceptions
     * Find purchase order by ID
     */
    async getOrderById(requestParameters: GetOrderByIdRequest): Promise<Order> {
        if (requestParameters.orderId === null || requestParameters.orderId === undefined) {
            throw new RequiredError('orderId','Required parameter requestParameters.orderId was null or undefined when calling getOrderById.');
        }

        const headerParameters: HTTPHeaders = {};

        return this.request<Order>({
            path: `/store/order/{orderId}`.replace(`{${"orderId"}}`, encodeURIComponent(String(requestParameters.orderId))),
            method: 'GET',
            headers: headerParameters,
            responseType: 'JSON',
            modelPropertyNaming: 'camelCase',
        });
    }

    /**
     * 
     * Place an order for a pet
     */
    async placeOrder(requestParameters: PlaceOrderRequest): Promise<Order> {
        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new RequiredError('body','Required parameter requestParameters.body was null or undefined when calling placeOrder.');
        }

        const headerParameters: HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        return this.request<Order>({
            path: `/store/order`,
            method: 'POST',
            headers: headerParameters,
            body: requestParameters.body,
            responseType: 'JSON',
            modelPropertyNaming: 'camelCase',
        });
    }

}

/**
 * no description
 */
export class UserApi extends BaseAPI {

    /**
     * This can only be done by the logged in user.
     * Create user
     */
    async createUser(requestParameters: CreateUserRequest): Promise<Response> {
        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new RequiredError('body','Required parameter requestParameters.body was null or undefined when calling createUser.');
        }

        const headerParameters: HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        return this.request<Response>({
            path: `/user`,
            method: 'POST',
            headers: headerParameters,
            body: requestParameters.body,
            modelPropertyNaming: 'camelCase',
        });
    }

    /**
     * 
     * Creates list of users with given input array
     */
    async createUsersWithArrayInput(requestParameters: CreateUsersWithArrayInputRequest): Promise<Response> {
        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new RequiredError('body','Required parameter requestParameters.body was null or undefined when calling createUsersWithArrayInput.');
        }

        const headerParameters: HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        return this.request<Response>({
            path: `/user/createWithArray`,
            method: 'POST',
            headers: headerParameters,
            body: requestParameters.body,
            modelPropertyNaming: 'camelCase',
        });
    }

    /**
     * 
     * Creates list of users with given input array
     */
    async createUsersWithListInput(requestParameters: CreateUsersWithListInputRequest): Promise<Response> {
        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new RequiredError('body','Required parameter requestParameters.body was null or undefined when calling createUsersWithListInput.');
        }

        const headerParameters: HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        return this.request<Response>({
            path: `/user/createWithList`,
            method: 'POST',
            headers: headerParameters,
            body: requestParameters.body,
            modelPropertyNaming: 'camelCase',
        });
    }

    /**
     * This can only be done by the logged in user.
     * Delete user
     */
    async deleteUser(requestParameters: DeleteUserRequest): Promise<Response> {
        if (requestParameters.username === null || requestParameters.username === undefined) {
            throw new RequiredError('username','Required parameter requestParameters.username was null or undefined when calling deleteUser.');
        }

        const headerParameters: HTTPHeaders = {};

        return this.request<Response>({
            path: `/user/{username}`.replace(`{${"username"}}`, encodeURIComponent(String(requestParameters.username))),
            method: 'DELETE',
            headers: headerParameters,
            modelPropertyNaming: 'camelCase',
        });
    }

    /**
     * 
     * Get user by user name
     */
    async getUserByName(requestParameters: GetUserByNameRequest): Promise<User> {
        if (requestParameters.username === null || requestParameters.username === undefined) {
            throw new RequiredError('username','Required parameter requestParameters.username was null or undefined when calling getUserByName.');
        }

        const headerParameters: HTTPHeaders = {};

        return this.request<User>({
            path: `/user/{username}`.replace(`{${"username"}}`, encodeURIComponent(String(requestParameters.username))),
            method: 'GET',
            headers: headerParameters,
            responseType: 'JSON',
            modelPropertyNaming: 'camelCase',
        });
    }

    /**
     * 
     * Logs user into the system
     */
    async loginUser(requestParameters: LoginUserRequest): Promise<string> {
        if (requestParameters.username === null || requestParameters.username === undefined) {
            throw new RequiredError('username','Required parameter requestParameters.username was null or undefined when calling loginUser.');
        }

        if (requestParameters.password === null || requestParameters.password === undefined) {
            throw new RequiredError('password','Required parameter requestParameters.password was null or undefined when calling loginUser.');
        }

        const queryParameters: HTTPQuery = {};

        if (requestParameters.username !== undefined) {
            queryParameters['username'] = requestParameters.username;
        }

        if (requestParameters.password !== undefined) {
            queryParameters['password'] = requestParameters.password;
        }

        const headerParameters: HTTPHeaders = {};

        return this.request<string>({
            path: `/user/login`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
            responseType: 'JSON',
            modelPropertyNaming: 'camelCase',
        });
    }

    /**
     * 
     * Logs out current logged in user session
     */
    async logoutUser(): Promise<Response> {
        const headerParameters: HTTPHeaders = {};

        return this.request<Response>({
            path: `/user/logout`,
            method: 'GET',
            headers: headerParameters,
            modelPropertyNaming: 'camelCase',
        });
    }

    /**
     * This can only be done by the logged in user.
     * Updated user
     */
    async updateUser(requestParameters: UpdateUserRequest): Promise<Response> {
        if (requestParameters.username === null || requestParameters.username === undefined) {
            throw new RequiredError('username','Required parameter requestParameters.username was null or undefined when calling updateUser.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new RequiredError('body','Required parameter requestParameters.body was null or undefined when calling updateUser.');
        }

        const headerParameters: HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        return this.request<Response>({
            path: `/user/{username}`.replace(`{${"username"}}`, encodeURIComponent(String(requestParameters.username))),
            method: 'PUT',
            headers: headerParameters,
            body: requestParameters.body,
            modelPropertyNaming: 'camelCase',
        });
    }

}



export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

export type FetchAPI = GlobalFetch['fetch'];

export interface ConfigurationParameters {
    basePath?: string; // override base path
    fetchApi?: FetchAPI; // override for fetch implementation
    middleware?: Middleware[]; // middleware to apply before/after fetch requests
    username?: string; // parameter for basic security
    password?: string; // parameter for basic security
    apiKey?: string | ((name: string) => string); // parameter for apiKey security
    accessToken?: string | ((name: string, scopes?: string[]) => string); // parameter for oauth2 security
}

export class Configuration {

    basePath: string;
    fetchApi: FetchAPI;
    middleware: Middleware[];
    username?: string;
    password?: string;
    apiKey?: (name: string) => string;
    accessToken?: (name: string, scopes?: string[]) => string;

    constructor(conf: ConfigurationParameters = {}) {
        this.basePath = conf.basePath !== undefined ? conf.basePath : BASE_PATH;
        this.fetchApi = conf.fetchApi || window.fetch.bind(window);
        this.middleware = conf.middleware || [];
        this.username = conf.username;
        this.password = conf.password;
        if (conf.apiKey) {
            this.apiKey = typeof conf.apiKey === 'function' ? conf.apiKey : () => conf.apiKey;
        }
        if (conf.accessToken) {
            this.accessToken = typeof conf.accessToken === 'function' ? conf.accessToken : () => conf.accessToken;
        }
    }
}

export type Json = any;
export type HTTPMethod = 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE' | 'OPTIONS';
export type HTTPHeaders = { [key: string]: string };
export type HTTPQuery = { [key: string]: string | number | null | boolean | Array<string | number | null | boolean> };
export type HTTPBody = Json | FormData;
export type ModelPropertyNaming = 'camelCase' | 'snake_case' | 'PascalCase' | 'original';

export interface FetchParams {
    url: string;
    init: RequestInit;
}

interface RequestOpts {
    path: string;
    method: HTTPMethod;
    headers: HTTPHeaders;
    query?: HTTPQuery;
    body?: HTTPBody;
    responseType?: 'JSON';
    modelPropertyNaming: ModelPropertyNaming;
}

function querystring(params: HTTPQuery) {
    return Object.keys(params)
        .map((key) => {
            const value = params[key];
            if (value instanceof Array) {
                const multiValue = value.join(`&${encodeURIComponent(key)}=`);
                return `${encodeURIComponent(key)}=${multiValue}`;
            }
            return `${encodeURIComponent(key)}=${encodeURIComponent(String(value))}`
        })
        .join('&');
}

export interface Middleware {
    pre?(fetch: FetchAPI, url: string, init: RequestInit): Promise<FetchParams | undefined | void>;
    post?(fetch: FetchAPI, url: string, init: RequestInit, response: Response): Promise<Response | undefined | void>;
}

function toCamelCase(name: string) {
    return (name.charAt(0).toLowerCase() + name.slice(1) || name).toString();
}

function applyPropertyNameConverter(json: any, converter: (name: string) => string) {
    if (json instanceof Array) {
        json.forEach((value) => {
            if (typeof value === 'object') {
                return applyPropertyNameConverter(value, converter);
            }
        });
    } else {
        Object.keys(json).forEach((origKey) => {
            if (json.hasOwnProperty(origKey)) {
                let value = json[origKey];
                if (value instanceof Array || (value !== null && value.constructor === Object)) {
                    value = applyPropertyNameConverter(value, converter);
                }
                const newKey = converter(origKey);
                json[newKey] = json[origKey];
                delete json[origKey];
                json[newKey] = value;
            }
        });
    }
    return json;
}

function transformPropertyNames(json: any, modelPropertyNaming: ModelPropertyNaming) {
    switch (modelPropertyNaming) {
        case 'camelCase':
            return applyPropertyNameConverter(json, toCamelCase);

        case 'original':
        default:
            return json;
    }
}
